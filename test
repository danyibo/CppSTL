void PsirAlgo::RunBaseStack()
{
    // Predefined kernel sizes array
    static const int KerSizes[] = { 1, 3, 5, 7, 9, 11, 13, 17, 19, 21 };
    static const int numKernels = sizeof(KerSizes) / sizeof(KerSizes[0]);

    // -------- 优化 1: 提前分配所有 slice 共用的大 buffer --------
    // 这样可以避免每个 slice 都 malloc/free
    std::vector<float> difBuffer(m_iSliceSize);
    std::vector<cFloat> multSeedSimage(numKernels * m_iSliceSize);

#pragma omp parallel for schedule(dynamic)
    for (int ss = 0; ss < m_iSlc; ++ss)
    {
        printf("slc %d doing ...\n", ss);

        // Slice pointers setup
        cFloat* pCurData       = m_pSrcData      + ss * m_iSliceSize;
        cFloat* pSimage        = m_pSImage.get() + ss * m_iSliceSize;
        float* pGr             = m_pGrImage.get() + ss * m_iSliceSize;
        int* pMask             = m_pMask.get() + ss * m_iSliceSize;
        int* pGrowMask         = m_pGrowMask.get() + ss * m_iSliceSize;
        float* pAbsDataCur     = m_pAbsData.get() + ss * m_iSliceSize;
        int* pAbsMaskCur       = m_pAbsMask.get() + ss * m_iSliceSize;
        int* pGlobalMaskCur    = m_pGlobalMask.get() + ss * m_iSliceSize;

        // Step 1: Classify data and create masks
        float lowThreshold = 0, highThreshold = 0, fMaxValue = 0;
        classifyData(pAbsDataCur, m_iSliceSize, lowThreshold, highThreshold, fMaxValue);

        const float maxThresh = fMaxValue * 0.1f;
        const float halfMaxThresh = fMaxValue * 0.5f;

        // -------- 优化 2: 合并两次 mask 计算到一次循环 --------
        for (int i = 0; i < m_iSliceSize; ++i)
        {
            const float val = pAbsDataCur[i];
            pGlobalMaskCur[i] = (val > maxThresh) ? 1 : 0;

            if (val > highThreshold)       pAbsMaskCur[i] = 1;
            else if (val < lowThreshold)   pAbsMaskCur[i] = -1;
            else                           pAbsMaskCur[i] = 0;
        }

        // Step 2: Compute angles (reversed RO PE)
        std::fill(difBuffer.begin(), difBuffer.end(), 0.0f);
        computeAngles(pCurData, &difBuffer[0], m_iPE, m_iRO);
        memcpy(pGr, &difBuffer[0], sizeof(float) * m_iSliceSize);

        // Step 3: 多核结果初始化（一次性 memset）
        std::fill(multSeedSimage.begin(), multSeedSimage.end(), cFloat(0,0));

        // Step 4: Process each kernel size
        for (int ii = 0; ii < numKernels; ++ii)
        {
            memset(pMask, 0, m_iSliceSize * sizeof(int));
            cFloat* pSingleSeedSimage = &multSeedSimage[ii * m_iSliceSize];

            const int iRadius = KerSizes[ii];
            Coordinate CorStart;
            CorStart.X = 5;
            CorStart.Y = 5; // Fixed starting coordinate

            int iIndex = GetIndexByCor(CorStart);
            pSingleSeedSimage[iIndex] = pCurData[iIndex]; // Initialize seed point

            PriorityStackGroups stackGroups;
            stackGroups.groupHigh[0].push(CorStart);

            cFloat cGlobal(0, 0), cProcessed(0, 0);

            while (GetNextPixel(CorStart, stackGroups))
            {
                iIndex = GetIndexByCor(CorStart);
                GetSurroundingPixel(CorStart, pGr, pCurData, pMask, stackGroups, pAbsMaskCur);

                cFloat cLocal(0, 0);
                RegionGrowOnePixel(CorStart, pGrowMask, pSingleSeedSimage, pCurData, iRadius, cLocal);

                const cFloat cProcessSimage = pSingleSeedSimage[iIndex];
                cProcessed = cProcessed + cProcessSimage;

                if (pGlobalMaskCur[iIndex] == 1)
                    cGlobal = cGlobal + cProcessSimage;

                cFloat cCombined = fast_combine(cProcessed, cGlobal, cLocal);
                if (should_negate(pCurData[iIndex], cCombined))
                    pSingleSeedSimage[iIndex] = cFloat(-pCurData[iIndex].real(), -pCurData[iIndex].imag());
                else
                    pSingleSeedSimage[iIndex] = pCurData[iIndex];
            }
        }

        // Step 5: Align polarities to the first layer
        cFloat* pSeedSimageRef = &multSeedSimage[0];
        for (int s = 1; s < numKernels; ++s)
        {
            cFloat* pSingleSeedSimage = &multSeedSimage[s * m_iSliceSize];
            float fSum = 0;
            for (int i = 0; i < m_iSliceSize; ++i)
                fSum += cosf(std::arg(pSeedSimageRef[i])) * cosf(std::arg(pSingleSeedSimage[i]));

            if (fSum < 0)
                PolarityReversal(pSingleSeedSimage, m_iSliceSize);
        }

        // Step 6: Sum all kernel results
        for (int i = 0; i < m_iSliceSize; ++i)
        {
            cFloat sum(0, 0);
            for (int s = 0; s < numKernels; ++s)
            {
                const cFloat& val = multSeedSimage[s * m_iSliceSize + i];
                sum.real(sum.real() + val.real());
                sum.imag(sum.imag() + val.imag());
            }
            pSimage[i] = sum;
        }
    }
}
